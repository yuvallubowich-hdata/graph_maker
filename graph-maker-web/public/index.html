<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Knowledge Graph Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }
        
        .header {
            background-color: #343a40;
            color: white;
            padding: 1rem 0;
            margin-bottom: 2rem;
        }
        
        .graph-container {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            overflow: hidden;
            position: relative;
        }
        
        .upload-container {
            border: 2px dashed #ddd;
            border-radius: 5px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
            background-color: #fff;
            transition: all 0.3s ease;
        }
        
        .upload-container:hover {
            border-color: #0d6efd;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #6c757d;
            margin-bottom: 1rem;
        }
        
        .card {
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .entity-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .entity-item {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .entity-item:hover {
            background-color: #f8f9fa;
        }
        
        .graph-node {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }
        
        .graph-link {
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        
        .node-label {
            font-size: 10px;
            font-family: sans-serif;
            pointer-events: none;
            fill: #333;
        }
        
        .loading-spinner {
            display: none;
            text-align: center;
            margin: 2rem 0;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="container">
            <div class="row align-items-center">
                <div class="col">
                    <h1>Document Knowledge Graph Builder</h1>
                    <p class="mb-0">Upload PDF documents to extract entities, relationships, and build a knowledge graph</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container">
        <!-- System Initialization -->
        <div class="row mb-4">
            <div class="col">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">System Initialization</h5>
                    </div>
                    <div class="card-body">
                        <p>Initialize the graph database and processing services before starting.</p>
                        <button id="initButton" class="btn btn-primary">
                            <i class="bi bi-database-check"></i> Initialize System
                        </button>
                        <button id="resetButton" class="btn btn-warning ms-2">
                            <i class="bi bi-arrow-counterclockwise"></i> Reset Entity Resolution
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- File Upload Section -->
        <div class="row mb-4">
            <div class="col">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Upload Documents</h5>
                    </div>
                    <div class="card-body">
                        <div class="upload-container" id="dropArea">
                            <div class="upload-icon">
                                <i class="bi bi-file-earmark-pdf"></i>
                            </div>
                            <h5>Drag & Drop PDF or Word files here</h5>
                            <p>or</p>
                            <form id="uploadForm" enctype="multipart/form-data">
                                <!-- Hidden input type fields for form submission -->
                                <div class="d-none">
                                    <input type="radio" name="inputType" id="inputTypeFile" value="file" checked>
                                    <input type="radio" name="inputType" id="inputTypeFolder" value="folder">
                                </div>
                                
                                <!-- Tab navigation for file/folder selection -->
                                <ul class="nav nav-tabs mb-3" id="uploadTabs" role="tablist">
                                    <li class="nav-item" role="presentation">
                                        <button class="nav-link active" id="files-tab" data-bs-toggle="tab" data-bs-target="#files-content" type="button" role="tab" aria-controls="files-content" aria-selected="true">Upload Files</button>
                                    </li>
                                    <li class="nav-item" role="presentation">
                                        <button class="nav-link" id="folder-tab" data-bs-toggle="tab" data-bs-target="#folder-content" type="button" role="tab" aria-controls="folder-content" aria-selected="false">Upload Folder</button>
                                    </li>
                                    <li class="nav-item" role="presentation">
                                        <button class="nav-link" id="tracking-tab" data-bs-toggle="tab" data-bs-target="#tracking-content" type="button" role="tab" aria-controls="tracking-content" aria-selected="false">File Tracking</button>
                                    </li>
                                </ul>
                                
                                <!-- Tab content -->
                                <div class="tab-content" id="uploadTabsContent">
                                    <!-- Files Tab -->
                                    <div class="tab-pane fade show active" id="files-content" role="tabpanel" aria-labelledby="files-tab">
                                        <div class="mb-3">
                                            <label for="fileInput" class="form-label">Upload PDF or Word Documents</label>
                                            <input class="form-control" type="file" id="fileInput" accept=".pdf,.doc,.docx" name="file" multiple>
                                        </div>
                                    </div>
                                    
                                    <!-- Folder Tab -->
                                    <div class="tab-pane fade" id="folder-content" role="tabpanel" aria-labelledby="folder-tab">
                                        <div class="mb-3">
                                            <label for="folderPath" class="form-label">Select Folder Containing PDFs</label>
                                            <div class="input-group">
                                                <input type="text" class="form-control" id="folderPath" name="folderPath" placeholder="Enter absolute folder path (e.g., /Users/username/Documents/PDFs)" required>
                                                <button class="btn btn-outline-secondary" type="button" id="browseFolderBtn">
                                                    <i class="bi bi-folder2-open"></i> Browse
                                                </button>
                                            </div>
                                            <div class="form-text">
                                                All PDF and Word files in the selected folder will be processed. Files already processed will be skipped. <strong>Important:</strong> You must provide an absolute path that the server can access.
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- File Tracking Tab -->
                                    <div class="tab-pane fade" id="tracking-content" role="tabpanel" aria-labelledby="tracking-tab">
                                        <div class="mb-3">
                                            <div class="d-flex justify-content-between mb-2">
                                                <h6>Previously Processed Files</h6>
                                                <div>
                                                    <button type="button" class="btn btn-sm btn-outline-primary me-2" id="refreshTrackingBtn">
                                                        <i class="bi bi-arrow-repeat"></i> Refresh
                                                    </button>
                                                    <button type="button" class="btn btn-sm btn-outline-danger" id="clearTrackingBtn">
                                                        <i class="bi bi-trash"></i> Clear All Records
                                                    </button>
                                                </div>
                                            </div>
                                            <div class="table-responsive" style="max-height: 200px; overflow-y: auto;">
                                                <table class="table table-sm table-hover">
                                                    <thead>
                                                        <tr>
                                                            <th>File Name</th>
                                                            <th>Status</th>
                                                            <th>Processed Date</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody id="processedFilesTable">
                                                        <tr>
                                                            <td colspan="3" class="text-center">Loading...</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <div class="form-text">
                                                <strong>Note:</strong> Clearing file tracking records allows reprocessing previously uploaded files.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label class="form-label">LLM Provider</label>
                                            <select class="form-select" id="llmProvider" name="llmProvider">
                                                <option value="openai">OpenAI (GPT-4)</option>
                                                <option value="gemini">Google Gemini 1.5 Flash</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label class="form-label">Processing Options</label>
                                            <div class="form-check form-switch">
                                                <input class="form-check-input" type="checkbox" id="parallelProcessing" name="parallelProcessing" value="true" checked>
                                                <label class="form-check-label" for="parallelProcessing">Enable Parallel Processing</label>
                                            </div>
                                            <div class="mt-2">
                                                <label for="concurrencyLimit" class="form-label">Concurrency Limit: <span id="concurrencyLabel">3</span></label>
                                                <input type="range" class="form-range" min="1" max="5" step="1" id="concurrencyLimit" name="concurrencyLimit" value="3" 
                                                    oninput="document.getElementById('concurrencyLabel').textContent = this.value">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-primary" type="button" id="uploadBtn" onclick="handleUploadClick(event)">
                                        <span class="spinner-border spinner-border-sm d-none" id="loadingSpinner" role="status" aria-hidden="true"></span>
                                        <span id="btnText">Upload & Process</span>
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Spinner -->
        <div class="modal fade" id="loadingModal" tabindex="-1" aria-labelledby="loadingModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="loadingModalLabel">Processing Files</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="text-center mb-3">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                        <p id="processingStatus">Preparing to process files...</p>
                        <div class="progress mb-3">
                            <div id="processingProgress" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                        <p id="fileCounter">0 files processed</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" id="stopUploadBtn" class="btn btn-warning">Stop Upload</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsContainer" class="card mt-4 d-none">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0">Processing Results</h5>
            </div>
            <div class="card-body">
                <div class="row mb-4">
                    <div class="col-md-4">
                        <div class="card text-white bg-primary">
                            <div class="card-body text-center">
                                <h6 class="card-title">Entities</h6>
                                <h2 id="entityCount">0</h2>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="card text-white bg-info">
                            <div class="card-body text-center">
                                <h6 class="card-title">Relationships</h6>
                                <h2 id="relationshipCount">0</h2>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="card text-white bg-dark">
                            <div class="card-body text-center">
                                <h6 class="card-title">Processing Time</h6>
                                <h2 id="processingTime">0s</h2>
                            </div>
                        </div>
                    </div>
                </div>
                
                <h5>Performance Analysis</h5>
                <div id="performanceDetails"></div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="row">
            <!-- Graph Statistics -->
            <div class="col-md-3">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Graph Statistics</h5>
                    </div>
                    <div class="card-body">
                        <div class="d-flex justify-content-between mb-2">
                            <span>Total Entities:</span>
                            <strong id="totalEntities">0</strong>
                        </div>
                        <div class="d-flex justify-content-between mb-2">
                            <span>Total Relationships:</span>
                            <strong id="totalRelationships">0</strong>
                        </div>
                        <hr>
                        <h6>Entity Types</h6>
                        <ul class="list-group list-group-flush" id="entityTypesList">
                            <li class="list-group-item">Loading...</li>
                        </ul>
                    </div>
                    <div class="card-footer">
                        <button id="refreshStatsButton" class="btn btn-sm btn-outline-secondary">
                            <i class="bi bi-arrow-repeat"></i> Refresh
                        </button>
                    </div>
                </div>
            </div>

            <!-- Entity Explorer -->
            <div class="col-md-3">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Entity Explorer</h5>
                        <div class="input-group input-group-sm" style="width: 150px;">
                            <input type="text" class="form-control" id="entitySearchInput" placeholder="Search...">
                            <button class="btn btn-outline-secondary" type="button" id="entitySearchButton">
                                <i class="bi bi-search"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div class="entity-list" id="entityList">
                            <div class="p-3 text-center">
                                <p>No entities to display</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Graph Visualization -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Knowledge Graph</h5>
                    </div>
                    <div class="card-body p-0">
                        <div class="graph-container" id="graphContainer"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Entity Details Modal -->
        <div class="modal fade" id="entityModal" tabindex="-1" aria-labelledby="entityModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="entityModalLabel">Entity Details</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" id="entityModalBody">
                        <div class="text-center">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>Loading entity details...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast container for notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header">
                <strong class="me-auto" id="toastTitle">Notification</strong>
                <small id="toastTime">just now</small>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body" id="toastMessage">
                
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global error handler
        window.addEventListener('error', function(event) {
            console.error('JavaScript error caught by global handler:', 
                event.message, 
                'at', event.filename, 
                'line:', event.lineno, 
                'column:', event.colno, 
                'error:', event.error
            );
        });

        // Define global toast notification function
        function showToast(title, message, type = 'info') {
            try {
                const toast = document.getElementById('notificationToast');
                const toastTitle = document.getElementById('toastTitle');
                const toastMessage = document.getElementById('toastMessage');
                const toastTime = document.getElementById('toastTime');
                
                // Set toast content
                toastTitle.textContent = title || 'Notification';
                toastMessage.textContent = message || '';
                toastTime.textContent = new Date().toLocaleTimeString();
                
                // Set toast styling based on type
                toast.classList.remove('bg-success', 'bg-danger', 'bg-warning', 'bg-info', 'text-white');
                if (type === 'success') {
                    toast.classList.add('bg-success', 'text-white');
                } else if (type === 'danger') {
                    toast.classList.add('bg-danger', 'text-white');
                } else if (type === 'warning') {
                    toast.classList.add('bg-warning');
                } else {
                    toast.classList.add('bg-info', 'text-white');
                }
                
                // Show the toast
                const bsToast = new bootstrap.Toast(toast);
                bsToast.show();
            } catch (toastError) {
                console.error('Error showing toast:', toastError);
                alert(`${title}: ${message}`);
            }
        }

        // Global variables for upload tracking
        let uploadClientId = null;
        let pollingInterval = null;
        let currentFiles = 0;
        let totalFiles = 0;
        let processingComplete = false;
        let modalClosed = false; // Track if modal has been closed already
        let startPollingTime = Date.now();

        // Function to show error toast, as a wrapper for showToast
        function showErrorToast(title, message, type = 'danger') {
            showToast(title, message, type);
        }

        // Function to safely close modal and clear resources
        function safeCloseModal() {
            // Only execute if not already closed
            if (modalClosed) {
                console.log("Modal already closed, skipping");
                return;
            }
            
            modalClosed = true;
            console.log("Safely closing modal and clearing resources");
            
            // Clear any polling interval
            if (pollingInterval) {
                console.log("Clearing polling interval");
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            
            // Hide the modal if it exists
            try {
                const modalElement = document.getElementById('loadingModal');
                if (modalElement) {
                    const modalInstance = bootstrap.Modal.getInstance(modalElement);
                    if (modalInstance) {
                        console.log("Hiding modal via Bootstrap instance");
                        modalInstance.hide();
                    } else {
                        console.log("Modal instance not found, trying alternative methods");
                        if (typeof $ !== 'undefined') {
                            $(modalElement).modal('hide');
                        }
                    }
                }
            } catch (modalError) {
                console.error('Error hiding modal:', modalError);
            }
            
            // Reset form state
            try {
                const uploadBtn = document.getElementById('uploadBtn');
                if (uploadBtn) {
                    uploadBtn.disabled = false;
                    const loadingSpinner = document.getElementById('loadingSpinner');
                    if (loadingSpinner) loadingSpinner.classList.add('d-none');
                    const btnText = document.getElementById('btnText');
                    if (btnText) btnText.textContent = 'Upload & Process';
                }
            } catch (resetError) {
                console.error('Error resetting form state:', resetError);
            }
        }

        // Function to handle upload button clicks
        function handleUploadClick(event) {
            event.preventDefault();
            console.log("Upload button clicked via onclick attribute");
            if (typeof processFormSubmission === 'function') {
                processFormSubmission();
            } else {
                console.error("processFormSubmission function not available yet");
            }
        }

        // Global form submission function
        async function processFormSubmission() {
            console.log("Processing form submission");
            
            // Reset modal closed flag for new submission
            modalClosed = false;
            processingComplete = false;
            
            // Get references to UI elements that need to be globally available
            const uploadBtn = document.getElementById('uploadBtn');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const btnText = document.getElementById('btnText');
            const loadingModalElement = document.getElementById('loadingModal');
            const loadingModal = new bootstrap.Modal(loadingModalElement);
            const processingStatus = document.getElementById('processingStatus');
            const processingProgress = document.getElementById('processingProgress');
            const fileCounter = document.getElementById('fileCounter');
            
            // Ensure the modal doesn't stay open indefinitely
            let modalTimeout = setTimeout(() => {
                try {
                    console.log("Safety timeout - closing modal after 2 minutes");
                    safeCloseModal();
                    showToast('Processing Complete', 'File processing may have completed in the background.', 'info');
                } catch (e) {
                    console.error("Error in safety timeout:", e);
                }
            }, 120000); // 2 minutes
            
            // Function to reset form state - define this before any try/catch to ensure availability
            function resetFormState() {
                if (uploadBtn) {
                    uploadBtn.disabled = false;
                    loadingSpinner.classList.add('d-none');
                    btnText.textContent = 'Upload & Process';
                }
                
                // Clear polling if it's active
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
            }
            
            // Handle processing completion
            function handleProcessingComplete(success, message) {
                console.log("Processing complete. Success:", success, "Message:", message);
                processingComplete = true;
                
                // Clear the safety timeout
                if (modalTimeout) {
                    clearTimeout(modalTimeout);
                    modalTimeout = null;
                }
                
                // Use the safe modal closing function
                safeCloseModal();
                
                if (success) {
                    showToast('Success', message || 'Files processed successfully!', 'success');
                } else {
                    showErrorToast('Error', message || 'There was an error processing the files.');
                }
                
                // Refresh UI components
                if (typeof loadLatestEntities === 'function') {
                    try {
                        loadLatestEntities();
                    } catch (e) {
                        console.error("Error refreshing entities:", e);
                    }
                }
                
                if (typeof loadGraphStats === 'function') {
                    try {
                        loadGraphStats();
                    } catch (e) {
                        console.error("Error refreshing graph stats:", e);
                    }
                }
                
                // Clear the upload form
                const uploadForm = document.getElementById('uploadForm');
                if (uploadForm) {
                    uploadForm.reset();
                }
            }
            
            // Function to check processing status
            async function checkProcessingStatus(clientId) {
                if (processingComplete || modalClosed) {
                    if (pollingInterval) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                    }
                    return;
                }
                
                try {
                    const response = await fetch(`/api/pdf/status/${clientId}`);
                    if (!response.ok) {
                        console.error('Error getting status:', response.statusText);
                        
                        // If we've had multiple errors, consider processing complete
                        const errorCount = (checkProcessingStatus.errorCount || 0) + 1;
                        checkProcessingStatus.errorCount = errorCount;
                        
                        if (errorCount >= 3) {
                            console.warn(`Multiple status check errors (${errorCount}), assuming processing is complete`);
                            handleProcessingComplete(true, "Processing likely completed (connection issues)");
                        }
                        return;
                    }
                    
                    // Reset error count if successful
                    checkProcessingStatus.errorCount = 0;
                    
                    const data = await response.json();
                    console.log('Status update:', data);
                    
                    // Check if this is a stale session
                    const twoMinutesAgo = Date.now() - (2 * 60 * 1000);
                    if (data.timestamp && data.timestamp < twoMinutesAgo) {
                        console.warn("Received stale status update, session may be orphaned");
                        handleProcessingComplete(true, "Processing likely completed while you were away");
                        return;
                    }
                    
                    // Update UI based on status
                    if (data.status === 'processing') {
                        updateProgressUI(data);
                    } else if (data.status === 'complete') {
                        updateProgressUI(data);
                        handleProcessingComplete(true, data.message || 'Processing complete');
                    } else if (data.status === 'error') {
                        updateProgressUI(data);
                        handleProcessingComplete(false, data.error || 'Error processing files');
                    } else if (data.status === 'cancelled') {
                        updateProgressUI(data);
                        handleProcessingComplete(false, data.message || 'Processing was cancelled');
                    } else if (data.status === 'unknown') {
                        // If no status is found after a while, assume processing is complete
                        const pollingDuration = Date.now() - startPollingTime;
                        if (pollingDuration > 20000) { // 20 seconds
                            console.warn("No status updates received for 20 seconds, assuming processing is complete");
                            handleProcessingComplete(true, "Processing likely completed (no status updates)");
                        }
                    }
                } catch (error) {
                    console.error('Error checking status:', error);
                    
                    // Count errors
                    const errorCount = (checkProcessingStatus.errorCount || 0) + 1;
                    checkProcessingStatus.errorCount = errorCount;
                    
                    // If we've been polling for over 30 seconds with errors, close modal
                    const pollingDuration = Date.now() - startPollingTime;
                    if (pollingDuration > 30000 || errorCount >= 5) { // 30 seconds or 5 consecutive errors
                        console.warn(`Status checking has been failing (${errorCount} errors), closing modal`);
                        handleProcessingComplete(true, "Processing status unknown, but likely completed");
                    }
                }
            }
            
            // Update the stopUploadProcess function to use safeCloseModal
            window.stopUploadProcess = async function() {
                try {
                    if (!uploadClientId) {
                        console.log("No active upload to cancel");
                        return;
                    }
                    
                    console.log(`Stopping upload for client ID: ${uploadClientId}`);
                    
                    // Disable the stop button and update its text
                    const stopBtn = document.getElementById('stopUploadBtn');
                    if (stopBtn) {
                        stopBtn.disabled = true;
                        stopBtn.textContent = 'Stopping...';
                    }
                    
                    // Call the cancel endpoint
                    const response = await fetch(`/api/pdf/cancel/${uploadClientId}`, {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Upload cancelled:', result);
                        showToast('Upload Stopped', 'The upload process has been cancelled.', 'warning');
                        
                        // Use safe close method
                        safeCloseModal();
                    } else {
                        console.error('Failed to cancel upload:', response.statusText);
                        showErrorToast('Error', 'Failed to cancel the upload. It may continue in the background.');
                        
                        // Re-enable the stop button
                        if (stopBtn) {
                            stopBtn.disabled = false;
                            stopBtn.textContent = 'Stop Upload';
                        }
                    }
                } catch (error) {
                    console.error('Error cancelling upload:', error);
                    showErrorToast('Error', 'An error occurred while trying to cancel the upload.');
                }
            };
            
            // Function to update the progress UI
            function updateProgressUI(data) {
                if (!processingStatus || !processingProgress || !fileCounter) {
                    console.error('Missing UI elements for progress updates');
                    return;
                }
                
                // Update progress message
                if (data.message) {
                    processingStatus.textContent = data.message;
                }
                
                // Update progress bar if percentage is available
                if (data.percentComplete !== undefined) {
                    const percent = Math.min(Math.max(data.percentComplete, 0), 100);
                    processingProgress.style.width = `${percent}%`;
                    processingProgress.setAttribute('aria-valuenow', percent);
                }
                
                // Update file counter
                if (data.totalFiles !== undefined || data.filesProcessed !== undefined) {
                    totalFiles = data.totalFiles !== undefined ? data.totalFiles : totalFiles;
                    currentFiles = data.filesProcessed !== undefined ? data.filesProcessed : currentFiles;
                    
                    fileCounter.textContent = `Files: ${currentFiles} / ${totalFiles || 'calculating...'}`;
                }
            }

            // Start polling for status updates
            function startStatusPolling(clientId) {
                // Store the client ID globally
                uploadClientId = clientId;
                startPollingTime = Date.now();
                
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                }
                
                // Initial status check
                checkProcessingStatus(clientId);
                
                // Set up regular polling
                pollingInterval = setInterval(() => {
                    checkProcessingStatus(clientId);
                }, 1000); // Poll every second
            }
            
            // Main upload processing logic
            try {
                // Disable button and show loading state
                uploadBtn.disabled = true;
                loadingSpinner.classList.remove('d-none');
                btnText.textContent = 'Processing...';
                
                // Get form data
                const form = document.getElementById('uploadForm');
                if (!form) {
                    throw new Error("Upload form not found in DOM");
                }
                
                const formData = new FormData(form);
                
                // Get selected input type (file or folder)
                const inputTypeEl = document.querySelector('input[name="inputType"]:checked');
                if (!inputTypeEl) {
                    throw new Error("Please select an input type (file or folder)");
                }
                const inputType = inputTypeEl.value;
                
                // Get file type if available
                const fileTypeEl = document.querySelector('input[name="fileType"]:checked');
                const fileType = fileTypeEl ? fileTypeEl.value : 'auto';
                
                // Initialize progress indicators
                fileCounter.textContent = 'Files Found: calculating...';
                processingStatus.textContent = 'Starting processing...';
                processingProgress.style.width = '0%';
                processingProgress.setAttribute('aria-valuenow', 0);
                
                // Show loading modal
                loadingModal.show();
                
                // Clear any existing polling
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
                
                // Generate a unique client ID for this upload
                const clientId = 'upload-' + Date.now();
                
                let response;
                if (inputType === 'file') {
                    // Handle file upload - direct multipart submission
                    response = await fetch('/api/pdf/upload', {
                        method: 'POST',
                        body: formData
                    });
                } else {
                    // Handle folder path submission
                    const folderPathEl = document.getElementById('folderPath');
                    if (!folderPathEl) {
                        throw new Error("Folder path input not found in DOM");
                    }
                    
                    const folderPath = folderPathEl.value;
                    
                    // Validate folder path
                    if (!folderPath) {
                        showErrorToast('Error', 'Please enter a folder path');
                        resetFormState();
                        loadingModal.hide();
                        return;
                    }
                    
                    response = await fetch('/api/pdf/upload/folder', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            folderPath: folderPath,
                            clientId: clientId
                        })
                    });
                }
                
                // Check response status
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Upload error:', errorText);
                    handleProcessingComplete(false, errorText || response.statusText);
                    return;
                }
                
                // Parse JSON response
                const data = await response.json();
                console.log('Upload response:', data);
                
                if (data.success && data.clientId) {
                    // Start polling for status updates
                    startStatusPolling(data.clientId);
                } else if (!data.success) {
                    handleProcessingComplete(false, data.error || 'Unknown error processing files');
                }
            } catch (error) {
                console.error('Error submitting form:', error);
                handleProcessingComplete(false, error.message || 'Error processing files');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('Document loaded, initializing application...');
            
            // Check that the form exists
            if (!document.getElementById('uploadForm')) {
                console.error("CRITICAL ERROR: Upload form not found! The form with ID 'uploadForm' does not exist in the DOM.");
                return;
            }
            
            console.log("Upload form found:", document.getElementById('uploadForm'));
            
            // DOM elements
            const uploadForm = document.getElementById('uploadForm');
            const fileInput = document.getElementById('fileInput');
            const uploadBtn = document.getElementById('uploadBtn');
            const dropArea = document.getElementById('dropArea');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const btnText = document.getElementById('btnText');
            const refreshStatsButton = document.getElementById('refreshStatsButton');
            const entityList = document.getElementById('entityList');
            const totalEntities = document.getElementById('totalEntities');
            const totalRelationships = document.getElementById('totalRelationships');
            const entityTypesList = document.getElementById('entityTypesList');
            const entitySearchInput = document.getElementById('entitySearchInput');
            const entitySearchButton = document.getElementById('entitySearchButton');
            const graphContainer = document.getElementById('graphContainer');
            const entityModal = new bootstrap.Modal(document.getElementById('entityModal'));
            
            // File tracking elements
            const processedFilesTable = document.getElementById('processedFilesTable');
            const refreshTrackingBtn = document.getElementById('refreshTrackingBtn');
            const clearTrackingBtn = document.getElementById('clearTrackingBtn');
            const browseFolderBtn = document.getElementById('browseFolderBtn');
            const folderPath = document.getElementById('folderPath');
            
            // Load processed files on tab selection
            document.getElementById('tracking-tab').addEventListener('click', loadProcessedFiles);
            
            // Add click handlers for file tracking
            refreshTrackingBtn.addEventListener('click', loadProcessedFiles);
            clearTrackingBtn.addEventListener('click', clearFileTracking);
            
            // Handle folder browsing (this requires additional native file access API)
            browseFolderBtn.addEventListener('click', async function() {
                // Folder selection via browser API doesn't work with Node.js server
                // because the server needs the full system path
                let folderPathInput = '';
                
                try {
                    // Modern browsers may support directory picker
                    if (window.showDirectoryPicker) {
                        try {
                            console.log("Using modern directory picker API");
                            const dirHandle = await window.showDirectoryPicker();
                            // Just get the name of the directory
                            folderPathInput = dirHandle.name;
                            
                            // Get the user's platform
                            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                            const isWindows = navigator.platform.toUpperCase().indexOf('WIN') >= 0;
                            
                            let placeholder = '';
                            if (isMac) {
                                placeholder = `/Users/username/Documents/${dirHandle.name}`;
                            } else if (isWindows) {
                                placeholder = `C:\\Users\\username\\Documents\\${dirHandle.name}`;
                            } else {
                                placeholder = `/home/username/Documents/${dirHandle.name}`;
                            }
                            
                            // Inform user they need to provide the full path
                            folderPathInput = prompt(`You selected: "${dirHandle.name}"
                            
You need to provide the COMPLETE absolute path to this folder on the server:`, placeholder);
                        } catch (e) {
                            console.log("Directory picker failed:", e);
                            // Fallback to prompt if user cancels or browser doesn't fully support
                            folderPathInput = prompt('Enter the complete absolute folder path that the server can access (e.g., /Users/username/Documents/PDFs):', '');
                        }
                    } else {
                        // Fallback for browsers without directory picker
                        folderPathInput = prompt('Enter the complete absolute folder path that the server can access (e.g., /Users/username/Documents/PDFs):', '');
                    }
                } catch (e) {
                    console.error("Error in folder selection:", e);
                    folderPathInput = prompt('Enter the complete absolute folder path that the server can access (e.g., /Users/username/Documents/PDFs):', '');
                }
                
                if (folderPathInput) {
                    // Sanitize the input path
                    folderPathInput = folderPathInput.trim();
                    
                    // Add simple path validation
                    const isValidPath = /^(\/|[a-zA-Z]:\\)/.test(folderPathInput);
                    
                    if (!isValidPath) {
                        showToast('Warning', 'The path you entered may not be valid. It should start with / (Unix/Mac) or C:\\ (Windows)', 'warning');
                    }
                    
                    folderPath.value = folderPathInput;
                    showToast('Folder Path Set', `Folder path set to: ${folderPathInput}`, 'info');
                    
                    // Add instruction about PDF/Word files
                    showToast('Important', 'Make sure this path contains PDF or Word files and exists on the server', 'warning');
                }
            });
            
            // Load the list of processed files
            async function loadProcessedFiles() {
                try {
                    processedFilesTable.innerHTML = '<tr><td colspan="3" class="text-center"><div class="spinner-border spinner-border-sm text-primary" role="status"></div> Loading...</td></tr>';
                    
                    const response = await fetch('/api/pdf/processed-files');
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.files && data.files.length > 0) {
                            const sortedFiles = data.files.sort((a, b) => 
                                new Date(b.processedAt) - new Date(a.processedAt)
                            );
                            
                            let tableHtml = '';
                            sortedFiles.forEach(file => {
                                const date = new Date(file.processedAt).toLocaleString();
                                const statusClass = file.status === 'processed' ? 'text-success' : 'text-danger';
                                const statusText = file.status === 'processed' ? 'Success' : 'Failed';
                                
                                tableHtml += `
                                    <tr>
                                        <td title="${file.filePath}">${file.originalName}</td>
                                        <td class="${statusClass}">${statusText}</td>
                                        <td>${date}</td>
                                    </tr>
                                `;
                            });
                            
                            processedFilesTable.innerHTML = tableHtml;
                        } else {
                            processedFilesTable.innerHTML = '<tr><td colspan="3" class="text-center">No processed files found</td></tr>';
                        }
                    } else {
                        throw new Error(data.error || 'Failed to load processed files');
                    }
                } catch (error) {
                    console.error('Error loading processed files:', error);
                    processedFilesTable.innerHTML = `<tr><td colspan="3" class="text-center text-danger">Error: ${error.message}</td></tr>`;
                }
            }
            
            // Clear all file tracking records
            async function clearFileTracking() {
                if (!confirm('Are you sure you want to clear all file tracking records? This will allow previously processed files to be reprocessed.')) {
                    return;
                }
                
                try {
                    const response = await fetch('/api/pdf/clear-tracking', {
                        method: 'POST'
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        showToast('Success', data.message, 'success');
                        loadProcessedFiles(); // Refresh the table
                    } else {
                        throw new Error(data.error || 'Failed to clear tracking records');
                    }
                } catch (error) {
                    console.error('Error clearing tracking records:', error);
                    showToast('Error', error.message, 'danger');
                }
            }
            
            // Load most recent entities
            async function loadLatestEntities() {
                try {
                    // First get the entity types
                    const typesResponse = await fetch('/api/graph/entity-types');
                    const types = await typesResponse.json();
                    
                    if (types && types.length) {
                        // Find the type with the most entities
                        const mostPopulatedType = types.reduce(
                            (prev, current) => (prev.count > current.count) ? prev : current
                        );
                        
                        // Load entities of that type
                        if (mostPopulatedType && mostPopulatedType.type) {
                            await loadEntitiesByType(mostPopulatedType.type);
                            
                            // Get the first entity to visualize
                            const entitiesResponse = await fetch(`/api/graph/entities/${mostPopulatedType.type}?limit=1`);
                            const entities = await entitiesResponse.json();
                            
                            if (entities && entities.length > 0) {
                                // Visualize the first entity
                                await visualizeEntity(entities[0].id);
                            } else {
                                graphContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><p>No entities available to visualize</p></div>';
                            }
                        }
                    } else {
                        entityList.innerHTML = '<div class="p-3 text-center"><p>No entities found</p></div>';
                        graphContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><p>No entities available to visualize</p></div>';
                    }
                } catch (error) {
                    console.error('Error loading latest entities:', error);
                    entityList.innerHTML = '<div class="p-3 text-center text-danger"><p>Error loading entities</p></div>';
                    graphContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><p class="text-danger">Error loading graph</p></div>';
                }
            }
            
            async function loadGraphStats() {
                try {
                    // Get graph stats
                    const statsResponse = await fetch('/api/graph/stats');
                    const stats = await statsResponse.json();
                    
                    totalEntities.textContent = stats.nodes;
                    totalRelationships.textContent = stats.relationships;
                    
                    // Get entity types
                    const typesResponse = await fetch('/api/graph/entity-types');
                    const types = await typesResponse.json();
                    
                    if (types && types.length) {
                        entityTypesList.innerHTML = '';
                        types.forEach(type => {
                            const item = document.createElement('li');
                            item.className = 'list-group-item d-flex justify-content-between align-items-center';
                            item.innerHTML = `
                                ${type.type}
                                <span class="badge bg-primary rounded-pill">${type.count}</span>
                            `;
                            item.dataset.type = type.type;
                            item.style.cursor = 'pointer';
                            item.addEventListener('click', () => loadEntitiesByType(type.type));
                            entityTypesList.appendChild(item);
                        });
                    } else {
                        entityTypesList.innerHTML = '<li class="list-group-item">No entity types found</li>';
                    }
                } catch (error) {
                    console.error('Error loading graph statistics:', error);
                    entityTypesList.innerHTML = '<li class="list-group-item text-danger">Error loading entity types</li>';
                }
            }
            
            // Load entities by type
            async function loadEntitiesByType(type) {
                try {
                    const response = await fetch(`/api/graph/entities/${type}`);
                    const entities = await response.json();
                    
                    if (entities && entities.length) {
                        entityList.innerHTML = '';
                        entities.forEach(entity => {
                            const item = document.createElement('div');
                            item.className = 'entity-item p-2 border-bottom';
                            item.innerHTML = `
                                <div class="fw-bold">${entity.name}</div>
                                <div class="small text-muted">${entity.labels.join(', ')}</div>
                            `;
                            item.dataset.id = entity.id;
                            item.addEventListener('click', () => showEntityDetails(entity.id));
                            entityList.appendChild(item);
                        });
                    } else {
                        entityList.innerHTML = '<div class="p-3 text-center"><p>No entities found</p></div>';
                    }
                } catch (error) {
                    console.error(`Error loading entities of type ${type}:`, error);
                    entityList.innerHTML = '<div class="p-3 text-center text-danger"><p>Error loading entities</p></div>';
                }
            }
            
            // Search entities
            entitySearchButton.addEventListener('click', searchEntities);
            entitySearchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchEntities();
                }
            });
            
            async function searchEntities() {
                const query = entitySearchInput.value.trim();
                if (!query) return;
                
                try {
                    const response = await fetch(`/api/graph/search?query=${encodeURIComponent(query)}`);
                    const entities = await response.json();
                    
                    if (entities && entities.length) {
                        entityList.innerHTML = '';
                        entities.forEach(entity => {
                            const item = document.createElement('div');
                            item.className = 'entity-item p-2 border-bottom';
                            item.innerHTML = `
                                <div class="fw-bold">${entity.name}</div>
                                <div class="small text-muted">${entity.labels.join(', ')}</div>
                            `;
                            item.dataset.id = entity.id;
                            item.addEventListener('click', () => showEntityDetails(entity.id));
                            entityList.appendChild(item);
                        });
                    } else {
                        entityList.innerHTML = '<div class="p-3 text-center"><p>No entities found</p></div>';
                    }
                } catch (error) {
                    console.error('Error searching entities:', error);
                    entityList.innerHTML = '<div class="p-3 text-center text-danger"><p>Error searching entities</p></div>';
                }
            }
            
            // Show entity details and visualization
            async function showEntityDetails(entityId) {
                try {
                    document.getElementById('entityModalBody').innerHTML = `
                        <div class="text-center">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>Loading entity details...</p>
                        </div>
                    `;
                    
                    entityModal.show();
                    
                    // Check if entity exists first
                    const checkResponse = await fetch(`/api/graph/entity/${entityId}`);
                    
                    if (!checkResponse.ok) {
                        // Entity doesn't exist - show error and offer to remove it from visualization
                        document.getElementById('entityModalBody').innerHTML = `
                            <div class="p-3 text-center text-danger">
                                <i class="bi bi-exclamation-triangle" style="font-size: 2rem;"></i>
                                <p class="mt-3">This entity no longer exists in the database.</p>
                                <p>It may have been deleted or incorrectly imported.</p>
                                <button id="refreshGraphBtn" class="btn btn-primary mt-3">
                                    <i class="bi bi-arrow-repeat"></i> Refresh Graph
                                </button>
                            </div>
                        `;
                        
                        // Add event listener to the refresh button
                        document.getElementById('refreshGraphBtn').addEventListener('click', function() {
                            entityModal.hide();
                            // Force a refresh of the graph data
                            loadLatestEntities();
                        });
                        
                        return;
                    }
                    
                    const entity = await checkResponse.json();
                    
                    if (entity) {
                        document.getElementById('entityModalLabel').textContent = entity.name || 'Entity Details';
                        
                        // Ensure labels is an array even if undefined
                        const entityLabels = Array.isArray(entity.labels) ? entity.labels : [];
                        
                        let content = `
                            <div class="mb-3">
                                <h6>Details</h6>
                                <div class="mb-2">
                                    <strong>Type:</strong> ${entityLabels.join(', ') || 'Unknown'}
                                </div>
                                <div class="mb-2">
                                    <strong>Description:</strong> ${entity.description || 'No description available'}
                                </div>
                                <div class="mb-2">
                                    <strong>Aliases:</strong> ${entity.aliases && entity.aliases.length ? entity.aliases.join(', ') : 'None'}
                                </div>
                            </div>
                            
                            <div class="row">
                                <div class="col-md-6">
                                    <h6>Outgoing Relationships (${entity.outgoing ? entity.outgoing.length : 0})</h6>
                                    <div class="list-group">
                        `;
                        
                        if (entity.outgoing && entity.outgoing.length) {
                            entity.outgoing.forEach(rel => {
                                const targetLabels = Array.isArray(rel.target.labels) ? rel.target.labels : [];
                                const targetLabel = targetLabels.length > 0 ? targetLabels[0] : 'Entity';
                                
                                content += `
                                    <a href="#" class="list-group-item list-group-item-action" data-id="${rel.target.id}">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <div>
                                                <i class="bi bi-arrow-right"></i> 
                                                <span class="fw-bold">${rel.type || 'RELATED_TO'}</span> 
                                                <span>${rel.target.name || 'Unknown'}</span>
                                            </div>
                                            <span class="badge rounded-pill bg-light text-dark">${targetLabel}</span>
                                        </div>
                                    </a>
                                `;
                            });
                        } else {
                            content += '<div class="p-3 text-center"><p>No outgoing relationships</p></div>';
                        }
                        
                        content += `
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <h6>Incoming Relationships (${entity.incoming ? entity.incoming.length : 0})</h6>
                                    <div class="list-group">
                        `;
                        
                        if (entity.incoming && entity.incoming.length) {
                            entity.incoming.forEach(rel => {
                                const sourceLabels = Array.isArray(rel.source.labels) ? rel.source.labels : [];
                                const sourceLabel = sourceLabels.length > 0 ? sourceLabels[0] : 'Entity';
                                
                                content += `
                                    <a href="#" class="list-group-item list-group-item-action" data-id="${rel.source.id}">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <div>
                                                <i class="bi bi-arrow-left"></i> 
                                                <span class="fw-bold">${rel.type || 'RELATED_TO'}</span> 
                                                <span>${rel.source.name || 'Unknown'}</span>
                                            </div>
                                            <span class="badge rounded-pill bg-light text-dark">${sourceLabel}</span>
                                        </div>
                                    </a>
                                `;
                            });
                        } else {
                            content += '<div class="p-3 text-center"><p>No incoming relationships</p></div>';
                        }
                        
                        content += `
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mt-3 text-center">
                                <button class="btn btn-primary" id="visualizeEntityButton" data-id="${entityId}">
                                    <i class="bi bi-graph-up"></i> Visualize in Graph
                                </button>
                            </div>
                        `;
                        
                        document.getElementById('entityModalBody').innerHTML = content;
                        
                        // Add event listeners for relationship links
                        document.querySelectorAll('#entityModalBody .list-group-item').forEach(item => {
                            item.addEventListener('click', function(e) {
                                e.preventDefault();
                                const id = this.dataset.id;
                                if (id) {
                                    showEntityDetails(id);
                                }
                            });
                        });
                        
                        // Add event listener for visualization button
                        document.getElementById('visualizeEntityButton').addEventListener('click', function() {
                            entityModal.hide();
                            visualizeEntity(this.dataset.id);
                        });
                    } else {
                        document.getElementById('entityModalBody').innerHTML = '<div class="p-3 text-center text-danger"><p>Error loading entity details</p></div>';
                    }
                } catch (error) {
                    console.error(`Error loading entity ${entityId}:`, error);
                    document.getElementById('entityModalBody').innerHTML = '<div class="p-3 text-center text-danger"><p>Error loading entity details: ' + error.message + '</p></div>';
                }
            }
            
            // Visualize entity in graph
            async function visualizeEntity(entityId) {
                try {
                    graphContainer.innerHTML = `
                        <div class="d-flex justify-content-center align-items-center h-100">
                            <div class="text-center">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p>Loading graph visualization...</p>
                            </div>
                        </div>
                    `;
                    
                    console.log("Visualizing entity:", entityId);
                    const url = `/api/graph/visualization?entityId=${entityId}&depth=2&limit=100`;
                    console.log("Fetching from URL:", url);
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to fetch graph data: ${response.status} ${response.statusText}`);
                    }
                    
                    const graphData = await response.json();
                    console.log("Graph data received:", JSON.stringify(graphData));
                    
                    if (graphData && graphData.nodes && graphData.nodes.length > 0 && graphData.links && graphData.links.length > 0) {
                        graphContainer.innerHTML = '';
                        console.log(`Rendering graph with ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
                        createForceGraph(graphData);
                    } else {
                        console.log("Received empty or incomplete graph data:", graphData);
                        graphContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><p>No connections available for this entity</p></div>';
                    }
                } catch (error) {
                    console.error(`Error visualizing entity ${entityId}:`, error);
                    graphContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><p class="text-danger">Error loading graph visualization: ' + error.message + '</p></div>';
                }
            }
            
            // Create force-directed graph
            function createForceGraph(data) {
                // Clear previous graph if any
                graphContainer.innerHTML = '';
                
                const width = graphContainer.clientWidth || 500;
                const height = 500; // Fixed height to ensure visibility
                
                // Handle empty data
                if (!data || !data.nodes || data.nodes.length === 0) {
                    graphContainer.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><p>No graph data available</p></div>';
                    return;
                }
                
                console.log("Creating graph with data:", data);
                console.log(`Node count: ${data.nodes.length}, Link count: ${data.links ? data.links.length : 0}`);
                
                // Special case for single node (no links)
                if (data.nodes.length === 1 && (!data.links || data.links.length === 0)) {
                    console.log("Single node visualization");
                    const svg = d3.select(graphContainer)
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);
                    
                    // Create a single node in the center
                    const g = svg.append('g');
                    const node = g.append('circle')
                        .attr('cx', width/2)
                        .attr('cy', height/2)
                        .attr('r', 20)
                        .attr('fill', '#1f77b4')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 1.5);
                    
                    // Add label
                    g.append('text')
                        .attr('x', width/2)
                        .attr('y', height/2 - 30)
                        .attr('text-anchor', 'middle')
                        .attr('class', 'node-label')
                        .text(data.nodes[0].name);
                    
                    // Add click handler
                    node.on('click', function() {
                        showEntityDetails(data.nodes[0].id);
                    });
                    
                    return;
                }
                
                // Standard force-directed graph for multiple nodes
                const svg = d3.select(graphContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('viewBox', [0, 0, width, height])
                    .attr('style', 'max-width: 100%; height: auto;');
                
                // Create group for the graph
                const g = svg.append('g');
                
                // Create zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                // Apply zoom behavior to SVG
                svg.call(zoom);
                
                // Create color scale for node types
                const color = d3.scaleOrdinal(d3.schemeCategory10);
                
                // Ensure links array exists
                const links = data.links || [];
                
                // Fix any issues with the links data
                links.forEach(link => {
                    // Ensure source and target are strings for D3 lookup
                    if (typeof link.source === 'object') {
                        link.source = link.source?.id || null;
                    }
                    if (typeof link.target === 'object') {
                        link.target = link.target?.id || null;
                    }
                });
                
                // Remove any links with null source or target
                const validLinks = links.filter(link => link.source && link.target);
                
                // Create simulation with proper node and link references
                const simulation = d3.forceSimulation(data.nodes)
                    .force('link', d3.forceLink(validLinks).id(d => d.id).distance(100))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collide', d3.forceCollide().radius(30));
                
                // Create links with proper source/target references
                const link = g.append('g')
                    .attr('stroke', '#999')
                    .attr('stroke-opacity', 0.6)
                    .selectAll('line')
                    .data(validLinks)
                    .join('line')
                    .attr('stroke-width', 1.5);
                
                // Create nodes
                const node = g.append('g')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1.5)
                    .selectAll('circle')
                    .data(data.nodes)
                    .join('circle')
                    .attr('r', 10)
                    .attr('fill', d => color(d.group || d.label))
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                // Add titles to nodes for tooltips
                node.append('title')
                    .text(d => d.name);
                
                // Add labels to nodes
                const label = g.append('g')
                    .selectAll('text')
                    .data(data.nodes)
                    .join('text')
                    .attr('class', 'node-label')
                    .attr('dy', -15)
                    .attr('text-anchor', 'middle')
                    .text(d => d.name)
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                // Add event listener to nodes
                node.on('click', function(event, d) {
                    showEntityDetails(d.id);
                });
                
                // Update positions
                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    label
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });
                
                // Drag functions
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
            }
            
            // Refresh stats button
            refreshStatsButton.addEventListener('click', loadGraphStats);
            
            // Initial load
            loadGraphStats();
            
            // Try to load and visualize entities if there are any in the database
            initializeGraph();
            
            async function initializeGraph() {
                try {
                    const statsResponse = await fetch('/api/graph/stats');
                    const stats = await statsResponse.json();
                    
                    if (stats.nodes > 0) {
                        // If there are entities in the database, load and visualize them
                        await loadLatestEntities();
                    } else {
                        // Show a helpful message if no data exists yet
                        graphContainer.innerHTML = `
                            <div class="d-flex justify-content-center align-items-center h-100">
                                <div class="text-center">
                                    <i class="bi bi-graph-up" style="font-size: 3rem; color: #ccc;"></i>
                                    <p class="mt-3">No data in the knowledge graph yet</p>
                                    <p class="small text-muted">Upload PDF files to populate the graph</p>
                                </div>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error initializing graph:', error);
                    graphContainer.innerHTML = `
                        <div class="d-flex justify-content-center align-items-center h-100">
                            <div class="text-center text-danger">
                                <i class="bi bi-exclamation-triangle" style="font-size: 3rem;"></i>
                                <p class="mt-3">Error initializing graph</p>
                                <p class="small">Please check the console for details</p>
                            </div>
                        </div>
                    `;
                }
            }

            // Set up tab change listeners to update the hidden input type radios
            document.getElementById('files-tab').addEventListener('click', function() {
                document.getElementById('inputTypeFile').checked = true;
            });

            document.getElementById('folder-tab').addEventListener('click', function() {
                document.getElementById('inputTypeFolder').checked = true;
            });

            // Add event listener for the stop upload button
            const stopUploadBtn = document.getElementById('stopUploadBtn');
            if (stopUploadBtn) {
                stopUploadBtn.addEventListener('click', stopUploadProcess);
            }
        });
    </script>
</body>
</html> 